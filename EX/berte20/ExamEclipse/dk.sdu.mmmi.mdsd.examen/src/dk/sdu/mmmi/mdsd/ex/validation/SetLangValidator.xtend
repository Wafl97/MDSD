/*
 * generated by Xtext 2.33.0
 */
package dk.sdu.mmmi.mdsd.ex.validation

import java.util.ArrayList
import java.util.List
import org.eclipse.xtext.validation.Check
import dk.sdu.mmmi.mdsd.ex.setLang.Expression
import dk.sdu.mmmi.mdsd.ex.setLang.Filter
import dk.sdu.mmmi.mdsd.ex.setLang.IntValue
import dk.sdu.mmmi.mdsd.ex.setLang.Intersection
import dk.sdu.mmmi.mdsd.ex.setLang.Product
import dk.sdu.mmmi.mdsd.ex.setLang.Projection
import dk.sdu.mmmi.mdsd.ex.setLang.Record
import dk.sdu.mmmi.mdsd.ex.setLang.Ref
import dk.sdu.mmmi.mdsd.ex.setLang.Set
import dk.sdu.mmmi.mdsd.ex.setLang.SetLangPackage
import dk.sdu.mmmi.mdsd.ex.setLang.Tuple
import dk.sdu.mmmi.mdsd.ex.setLang.Union

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SetLangValidator extends AbstractSetLangValidator {
	
	public static val MULTIPLE_VALIE_TYPES = 'multiple_valie_types'

	// Make sure that a Set only contains one type of values
	@Check
	def checkSetTypeRestriction(Set set) {
		var hasInt = false;
		var hasTuple = false;
		for (v : set.values) {
			if (v instanceof IntValue) {
				hasInt = true;
			}
			else if (v instanceof Tuple) {
				hasTuple = true;
			}
			
			// Both are not allowed	
			if (hasInt && hasTuple) {
				error('Set cannot contain both Int and Tuple!',
					SetLangPackage.Literals.SET__VALUES,
					MULTIPLE_VALIE_TYPES
				)
				return
			}
		}
	}
	
	// Make sure that a Set only uses parameter of the correct type
	@Check
	def checkSetParameterUse(Record record) {
		for (m : record.members) {
			for (e : m.exp.expandExp) {
				
				if (e instanceof Set) {
					checkSetParameters(e, record)
				}
			}
		}
	}
	
	protected def void checkSetParameters(Set e, Record record) {
		var hasInt = false;
		var hasTuple = false;
		for (v : e.values) {
			if (v instanceof IntValue) {
				hasInt = true;
			}
			else if (v instanceof Tuple) {
				hasTuple = true;
			}
			else if (v instanceof Ref) {
				val type =  record.getRefType(v)
				if (type.equals('Int')) {
					hasInt = true;
				}
				else if (type.equals('Tuple')) {
					hasTuple = true;
				}
			}
			// Both are not allowed	
			if (hasInt && hasTuple) {
				error('Set cannot contain both Int and Tuple!',
					SetLangPackage.Literals.RECORD__MEMBERS,
					MULTIPLE_VALIE_TYPES
				)
			}
		}
	}
	
	def getRefType(Record record, Ref ref) {
		record.parameters.filter[e | e.name == ref.ref.name].toList.get(0).type
	}
	
	def expandExp(Expression exp) {
		val expanded = new ArrayList();
		exp.expand(expanded)
		expanded	
	}
	
	def dispatch void expand(Ref ref, List<Object> expanded) {
		expanded.add(ref.ref.name)
	}
	
	def dispatch void expand(Set set, List<Object> expanded) {
		expanded.add(set)
	}
	
	def dispatch void expand(Union union, List<Object> expanded) {
		union.left.expand(expanded)
		union.right.expand(expanded)
	}
	
	def dispatch void expand(Intersection intersection, List<Object> expanded) {
		intersection.left.expand(expanded)
		intersection.right.expand(expanded)
	}
	
	def dispatch void expand(Product product, List<Object> expanded) {
		product.left.expand(expanded)
		product.right.expand(expanded)
	}
	
	def dispatch void expand(Projection projection, List<Object> expanded) {
		projection.op.expand(expanded)
	}
	
	def dispatch void expand(Filter filter, List<Object> expanded) {
		filter.op.expand(expanded)
	}
	
}
