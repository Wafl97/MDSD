/**
 * generated by Xtext 2.33.0
 */
package dk.sdu.mmmi.mdsd.ex.validation;

import com.google.common.base.Objects;
import dk.sdu.mmmi.mdsd.ex.setLang.Expression;
import dk.sdu.mmmi.mdsd.ex.setLang.Filter;
import dk.sdu.mmmi.mdsd.ex.setLang.IntValue;
import dk.sdu.mmmi.mdsd.ex.setLang.Intersection;
import dk.sdu.mmmi.mdsd.ex.setLang.Member;
import dk.sdu.mmmi.mdsd.ex.setLang.Parameter;
import dk.sdu.mmmi.mdsd.ex.setLang.Product;
import dk.sdu.mmmi.mdsd.ex.setLang.Projection;
import dk.sdu.mmmi.mdsd.ex.setLang.Record;
import dk.sdu.mmmi.mdsd.ex.setLang.Ref;
import dk.sdu.mmmi.mdsd.ex.setLang.Set;
import dk.sdu.mmmi.mdsd.ex.setLang.SetLangPackage;
import dk.sdu.mmmi.mdsd.ex.setLang.Tuple;
import dk.sdu.mmmi.mdsd.ex.setLang.Union;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SetLangValidator extends AbstractSetLangValidator {
  public static final String MULTIPLE_VALIE_TYPES = "multiple_valie_types";

  @Check
  public void checkSetTypeRestriction(final Set set) {
    boolean hasInt = false;
    boolean hasTuple = false;
    EList<Expression> _values = set.getValues();
    for (final Expression v : _values) {
      {
        if ((v instanceof IntValue)) {
          hasInt = true;
        } else {
          if ((v instanceof Tuple)) {
            hasTuple = true;
          }
        }
        if ((hasInt && hasTuple)) {
          this.error("Set cannot contain both Int and Tuple!", 
            SetLangPackage.Literals.SET__VALUES, 
            SetLangValidator.MULTIPLE_VALIE_TYPES);
          return;
        }
      }
    }
  }

  @Check
  public void checkSetParameterUse(final Record record) {
    EList<Member> _members = record.getMembers();
    for (final Member m : _members) {
      ArrayList<Object> _expandExp = this.expandExp(m.getExp());
      for (final Object e : _expandExp) {
        if ((e instanceof Set)) {
          this.checkSetParameters(((Set)e), record);
        }
      }
    }
  }

  protected void checkSetParameters(final Set e, final Record record) {
    boolean hasInt = false;
    boolean hasTuple = false;
    EList<Expression> _values = e.getValues();
    for (final Expression v : _values) {
      {
        if ((v instanceof IntValue)) {
          hasInt = true;
        } else {
          if ((v instanceof Tuple)) {
            hasTuple = true;
          } else {
            if ((v instanceof Ref)) {
              final String type = this.getRefType(record, ((Ref)v));
              boolean _equals = type.equals("Int");
              if (_equals) {
                hasInt = true;
              } else {
                boolean _equals_1 = type.equals("Tuple");
                if (_equals_1) {
                  hasTuple = true;
                }
              }
            }
          }
        }
        if ((hasInt && hasTuple)) {
          this.error("Set cannot contain both Int and Tuple!", 
            SetLangPackage.Literals.RECORD__MEMBERS, 
            SetLangValidator.MULTIPLE_VALIE_TYPES);
        }
      }
    }
  }

  public String getRefType(final Record record, final Ref ref) {
    final Function1<Parameter, Boolean> _function = (Parameter e) -> {
      String _name = e.getName();
      String _name_1 = ref.getRef().getName();
      return Boolean.valueOf(Objects.equal(_name, _name_1));
    };
    return IterableExtensions.<Parameter>toList(IterableExtensions.<Parameter>filter(record.getParameters(), _function)).get(0).getType();
  }

  public ArrayList<Object> expandExp(final Expression exp) {
    ArrayList<Object> _xblockexpression = null;
    {
      final ArrayList<Object> expanded = new ArrayList<Object>();
      this.expand(exp, expanded);
      _xblockexpression = expanded;
    }
    return _xblockexpression;
  }

  protected void _expand(final Ref ref, final List<Object> expanded) {
    expanded.add(ref.getRef().getName());
  }

  protected void _expand(final Set set, final List<Object> expanded) {
    expanded.add(set);
  }

  protected void _expand(final Union union, final List<Object> expanded) {
    this.expand(union.getLeft(), expanded);
    this.expand(union.getRight(), expanded);
  }

  protected void _expand(final Intersection intersection, final List<Object> expanded) {
    this.expand(intersection.getLeft(), expanded);
    this.expand(intersection.getRight(), expanded);
  }

  protected void _expand(final Product product, final List<Object> expanded) {
    this.expand(product.getLeft(), expanded);
    this.expand(product.getRight(), expanded);
  }

  protected void _expand(final Projection projection, final List<Object> expanded) {
    this.expand(projection.getOp(), expanded);
  }

  protected void _expand(final Filter filter, final List<Object> expanded) {
    this.expand(filter.getOp(), expanded);
  }

  public void expand(final Expression filter, final List<Object> expanded) {
    if (filter instanceof Filter) {
      _expand((Filter)filter, expanded);
      return;
    } else if (filter instanceof Intersection) {
      _expand((Intersection)filter, expanded);
      return;
    } else if (filter instanceof Product) {
      _expand((Product)filter, expanded);
      return;
    } else if (filter instanceof Projection) {
      _expand((Projection)filter, expanded);
      return;
    } else if (filter instanceof Ref) {
      _expand((Ref)filter, expanded);
      return;
    } else if (filter instanceof Set) {
      _expand((Set)filter, expanded);
      return;
    } else if (filter instanceof Union) {
      _expand((Union)filter, expanded);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(filter, expanded).toString());
    }
  }
}
