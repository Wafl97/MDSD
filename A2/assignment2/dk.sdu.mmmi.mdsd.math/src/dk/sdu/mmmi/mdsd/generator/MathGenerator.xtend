/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Constant
import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.Sub
import dk.sdu.mmmi.mdsd.math.Mul
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.Add
import dk.sdu.mmmi.mdsd.math.VariableUse
import dk.sdu.mmmi.mdsd.math.LetBinding
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	//static Map<String, Integer> variables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val variables = resource.allContents.filter(MathExp).next.compute
		
		// You can replace with hovering, see Bettini Chapter 8
		variables.displayPanel
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
		
	def static Map<String, Integer> compute(MathExp math) {
		val variables = new HashMap<String, Integer>()
		
		val fwExp = new HashMap<String, Expression>()
		math.exps.forEach[exp | fwExp.put(exp.name, exp.exp)]
		
		math.exps.forEach[exp | {
			val res = exp.exp.computeExp(variables, fwExp)			
			variables.put(exp.name, res)
		}]
		return variables
	}
	
	def static int computeExp(Expression exp, Map<String, Integer> vars, Map<String, Expression> fwExp) {
		switch exp {
			Add: exp.left.computeExp(vars, fwExp)+exp.right.computeExp(vars, fwExp)
			Sub: exp.left.computeExp(vars, fwExp)-exp.right.computeExp(vars, fwExp)
			Mul: exp.left.computeExp(vars, fwExp)*exp.right.computeExp(vars, fwExp)
			Div: exp.left.computeExp(vars, fwExp)/exp.right.computeExp(vars, fwExp)
			Constant: exp.value
			Parenthesis: exp.exp.computeExp(vars, fwExp)
			VariableUse:
			{
				//exp.ref.computeBinding
				if (!vars.keySet.contains(exp.ref)) {
					val res = fwExp.get(exp.ref).computeExp(vars, fwExp)
					vars.put(exp.ref, res)
				}
				vars.get(exp.ref)
			}
			LetBinding: exp.body.computeExp(vars.bind(exp.name, exp.binding.computeExp(vars, fwExp)), fwExp)
			default: throw new Error("Could not compute expression")
		}
	}
	
	def static Map<String, Integer> bind(Map<String, Integer> vars, String key, Integer value) {
		val binding = new HashMap<String, Integer>(vars)
		binding.put(key, value)
		binding
	}

	def void displayPanel(Map<String, Integer> result) {
		
		var resultString = ""
		if (result.isEmpty()) { 
			resultString = "NO RESULT"
		}
		
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
}
